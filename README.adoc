# Sortition Pools

Sortition pool is a logarithmic data structure used to store the pool of eligible 
operators weighted by their stakes. It allows to select a group of operators
based on the provided pseudo-random seed and optional bonding requirements.

Each privileged application has its own sortition pool and eligibility is checked 
when an operator is selected, rejecting and removing ineligible operators from the pool.

Pool provides instant  selection results and is less affected by censorship that the
ticket selection, although malicious miners can still censor protocol result submissions.

## Overview

An operator enters a sortition pool by opting in. The pool checks their eligible tokens
(including operator status and authorization to slash stakes),
and optionally available bonding currency (including authorization to seize bonds).
The operator pays the transaction fees for the pool update.

Keeping these pools up to date cannot be done eagerly as proliferation of privileged 
customers could be used to perform DOS attacks by increasing the cost of such updates.
When a sortition pool prospectively selects an operator, the selected operator's 
eligibility status and weight are checked and, if necessary, updated in the sortition pool.
If the changes would be detrimental to the operator, the operator selection is performed 
again with the updated input to ensure correctness.

The number of operator selections required to get _n_ valid non-unique members
averages _n / (1 - e)_ where _e_ equals the fraction of weight in the pool
belonging to operators whose information is detrimentally out of date.
If 50% of the pool weight is outdated, the average number of selections is 6,
roughly 2% of ECDSA keeps would require 12 or more operator selections,
and more than 20 selections would be extremely rare.
Sortition pools that are used more often would be less outdated.

## Optimized higher arity trees

Even though logarithmic data structures are well-known,
the particular characteristics of Ethereum smart contracts
require specialized optimization
to make non-interactive sortition viable.

To enable weighted sortition,
each sortition pool would have a weighted tree
where each leaf stores an operator
and is labeled with the operator's sortition weight,
and each branch is labeled with the sum of the weights of its children.
To select an operator from the pool,
a pseudorandom number in _[0, W)_
(where _W_ is the total sortition weight of the tree)
is acquired and used to index into the tree.

A single storage field in the EVM consists of 256 bits/32 bytes.
Data structures on the EVM are naturally sparse.
An implicit heap can eliminate the need for pointers
so the full capacity of each storage field can be used for content data.

KEEP tokens have 18 decimals and the total supply is 1,000,000,000 KEEP.
A precise token amount would require roughly 96 bits/12 bytes to store.
However, the minimum stake required to participate
is expected to be in the region of 1/100,000 of the total KEEP supply.

Instead of using the exact token amount,
each operator's sortition weight should use their staker weight
as in the Random Beacon group selection.
Because a staker weight exceeding 65,535
would represent catastrophic centralization in the network,
16 bits is sufficient for all practical purposes
even if the minimum stake is somewhat less than 10,000 KEEP.

A storage field can hold 16 values of 16 bits.
This gives a theoretical ceiling of 1,048,560 possible virtual stakers
for a node containing the weights of its 16 children. 
With a pessimal distribution of child nodes' weights,
524,288 virtual stakers can be accommodated.
The maximum permitted staker weight of 65,535
represents approximately 13% of all tokens in the pessimal distribution.
Assuming each staker divides their staked tokens
equally between two different operators
as recommended for smooth upgrades,
a single actor following best practices would need to hold 25% of all KEEP
to be affected by the staker weight cap of 16 bits.
Such an actor would already be a threat to the Keep network
and we have no need to accommodate them,
so all child nodes can be capped to 16 bits without issues.


## Usage

### Bonded Sortition Pool

#### Creating a pool
```
import "@keep-network/sortition-pools/contracts/api/IStaking.sol";
import "@keep-network/sortition-pools/contracts/api/IBonding.sol";
import "@keep-network/sortition-pools/contracts/BondedSortitionPool.sol";
import "@keep-network/sortition-pools/contracts/BondedSortitionPoolFactory.sol";

(...)

BondedSortitionPoolFactory sortitionPoolFactory;

(...)

address sortitionPoolAddress = sortitionPoolFactory.createSortitionPool(
  IStaking(keepStakingContract),
  IBonding(keepBondingContract),
  minimumStake,
  minimumBond
);
```

#### Joining the pool

```
if (!pool.isOperatorInPool(operator)) {
  pool.joinPool(operator);
}
```

#### Updating status

```
if (!pool.isOperatorUpToDate(operator)) {
  pool.updateOperatorStatus(operator);
}
```

#### Selecting unique signers

```
address[] memory members = pool.selectSetGroup(
  groupSize,
  bytes32(groupSelectionSeed),
  memberBond
);
```        

### Sortition Pool with no bonding

#### Creating a pool

```
import "@keep-network/sortition-pools/contracts/SortitionPool.sol";
import "@keep-network/sortition-pools/contracts/SortitionPoolFactory.sol";

(...)

SortitionPoolFactory sortitionPoolFactory;

(...)

address sortitionPoolAddress = sortitionPoolFactory.createSortitionPool(
  IStaking(keepStakingContract),
  minimumStake,
);
```

#### Joining the pool

```
if (!pool.isOperatorInPool(operator)) {
  pool.joinPool(operator);
}
```

#### Updating status

```
if (!pool.isOperatorUpToDate(operator)) {
  pool.updateOperatorStatus(operator);
}
```

#### Selecting non-unique signers

```
address[] memory members = pool.selectGroup(
  groupSize,
  bytes32(groupSelectionSeed),
);
```  

